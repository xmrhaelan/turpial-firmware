
.. _program_listing_file_components_WS_src_WebSocket.cpp:

Program Listing for File WebSocket.cpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file_components_WS_src_WebSocket.cpp>` (``components/WS/src/WebSocket.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #include "WebSocket.h"
   #include "Task.h"
   #include <sstream>
   #include <esp_log.h>
   
   #include <iostream>
   using namespace std;
   
   extern "C" {
   extern uint16_t lwip_ntohs(uint16_t);
   extern uint32_t lwip_ntohl(uint32_t);
   extern uint16_t lwip_htons(uint16_t);
   extern uint32_t lwip_htonl(uint32_t);
   }
   
   static const char* LOG_TAG = "WebSocket";
   ws_list_t wsClients;
   
   
   // WebSocket op codes as found in a WebSocket frame.
   static const uint8_t OPCODE_CONTINUE = 0x00;
   static const uint8_t OPCODE_TEXT = 0x01;
   static const uint8_t OPCODE_BINARY = 0x02;
   static const uint8_t OPCODE_CLOSE = 0x08;
   static const uint8_t OPCODE_PING = 0x09;
   static const uint8_t OPCODE_PONG = 0x0a;
   
   
   // Structure definition for the WebSocket frame.
   struct Frame {
       // Byte 0
       uint8_t opCode : 4; // [7:4]
       uint8_t rsv3 : 1;   // [3]
       uint8_t rsv2 : 1;   // [2]
       uint8_t rsv1 : 1;   // [1]
       uint8_t fin : 1;    // [0]
   
       // Byte 1
       uint8_t len : 7;  // [7:1]
       uint8_t mask : 1; // [0]
   };
   
   
   static void dumpFrame(Frame frame)
   {
       std::ostringstream oss;
       oss << "Fin: " << (int)frame.fin << ", OpCode: " << (int)frame.opCode;
       switch (frame.opCode) {
       case OPCODE_BINARY: {
           oss << " BINARY";
           break;
       }
       case OPCODE_CONTINUE: {
           oss << " CONTINUE";
           break;
       }
       case OPCODE_CLOSE: {
           oss << " CLOSE";
           break;
       }
       case OPCODE_PING: {
           oss << " PING";
           break;
       }
       case OPCODE_PONG: {
           oss << " PONG";
           break;
       }
       case OPCODE_TEXT: {
           oss << " TEXT";
           break;
       }
       default: {
           oss << " Unknown";
           break;
       }
       }
       oss << ", Mask: " << (int)frame.mask << ", len: " << (int)frame.len;
       ESP_LOGD(LOG_TAG, "WebSocket frame: %s", oss.str().c_str());
   } // dumpFrame
   
   
   class WebSocketReader : public Task
   {
   public:
       WebSocketReader()
       {
           m_end = false;
       }
       void end()
       {
           m_end = true;
       }
   
   private:
       bool m_end;
       void run(void* data)
       {
           WebSocket* pWebSocket = (WebSocket*)data;
           ESP_LOGD("WebSocketReader", "WebSocketReader Task started, socket: %s", pWebSocket->getSocket().toString().c_str());
   
           Socket peerSocket = pWebSocket->getSocket();
   
           Frame frame;
           while (true) {
               if (m_end) break;
               ESP_LOGD("WebSocketReader", "Waiting on socket data for socket %s", peerSocket.toString().c_str());
               int length = peerSocket.receive((uint8_t*)&frame, sizeof(frame), true); // Read exact
               if (length != sizeof(frame)) {
                   ESP_LOGD("WebSocketReader", "Socket read error");
                   pWebSocket->close();
                   return;
               }
   
               ESP_LOGD("WebSocketReader", "Received data from web socket.  Length: %d", length);
               dumpFrame(frame);
   
               // The following section parses the WebSocket frame.
               uint32_t payloadLen = 0;
               uint8_t mask[4];
               if (frame.len < 126) {
                   payloadLen = frame.len;
               } else if (frame.len == 126) {
                   uint16_t tempLen;
                   peerSocket.receive((uint8_t*)&tempLen, sizeof(tempLen), true);
                   payloadLen = ntohs(tempLen);
               } else if (frame.len == 127) {
                   uint64_t tempLen;
                   peerSocket.receive((uint8_t*)&tempLen, sizeof(tempLen), true);
                   payloadLen = ntohl((uint32_t)tempLen);
               }
               if (frame.mask == 1) {
                   peerSocket.receive(mask, sizeof(mask), true);
               }
   
               if (payloadLen == 0) {
                   ESP_LOGD("WebSocketReader", "Web socket payload is not present");
               } else {
                   ESP_LOGD("WebSocketReader", "Web socket payload, length=%d:", payloadLen);
               }
   
               WebSocketHandler* pWebSocketHandler = pWebSocket->getHandler();
               switch (frame.opCode) {
               case OPCODE_TEXT:
               case OPCODE_BINARY: {
                   if (pWebSocketHandler != nullptr) {
                       WebSocketInputStreambuf streambuf(pWebSocket->getSocket(), payloadLen, (frame.mask == 1) ? mask : nullptr);
                       pWebSocketHandler->onMessage(&streambuf, pWebSocket);
                       //streambuf.discard();
                   }
                   break;
               }
   
               // If the WebSocket operation code is close then we are closing the connection.
               case OPCODE_CLOSE: {
                   pWebSocket->m_receivedClose = true;
                   if (pWebSocketHandler != nullptr) { // If we have a handler, invoke the onClose method upon it.
                       pWebSocketHandler->onClose(pWebSocket);
                   }
                   pWebSocket->close(); // Close the websocket.
                   break;
               }
   
               case OPCODE_CONTINUE: {
                   break;
               }
   
               case OPCODE_PING: {
                   break;
               }
   
               case OPCODE_PONG: {
                   break;
               }
   
               default: {
                   ESP_LOGD("WebSocketReader", "Unknown opcode: %d", frame.opCode);
                   break;
               }
               } // Switch opCode
   
           } // while (true)
           ESP_LOGD("WebSocketReader", "<< run");
       } // run
   };    // WebSocketReader
   
   
   void WebSocketHandler::onClose(WebSocket* pWebSocket)
   {
       ESP_LOGI("***************************************************WebSocketHandler", ">> onClose");
       ESP_LOGI("****************************************************WebSocketHandler", "<< onClose");
   } // onClose
   
   
   void WebSocketHandler::onMessage(WebSocketInputStreambuf* pWebSocketInputStreambuf, WebSocket* pWebSocket)
   {
       ostream s1(pWebSocketInputStreambuf);
       s1 << pWebSocketInputStreambuf;
       s1.rdbuf();
   
       ESP_LOGI("WebSocketHandler>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>", ">> onMessage");
       ESP_LOGI("WebSocketHandler<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<", "<< onMessage");
   
       stringstream s2;
       s2 << pWebSocketInputStreambuf;
   
       std::cout << "-----------------------------------LA SLAIDA ES " << s2.rdbuf()->str() << std::endl;
       pWebSocket->send("Helloworld", 0x02);
   } // onData
   
   
   void WebSocketHandler::onError(std::string error)
   {
       ESP_LOGD("WebSocketHandler", ">> DEFAULT onError: %s", error.c_str());
   } // onError
   
   
   WebSocket::WebSocket(Socket socket)
   {
       m_receivedClose = false;
       m_sentClose = false;
       m_socket = socket;
       m_pWebSockerReader = new WebSocketReader();
       m_pWebSocketHandler = nullptr;
   } // WebSocket
   
   
   WebSocket::~WebSocket()
   {
       m_pWebSockerReader->stop();
       delete m_pWebSockerReader;
   } // ~WebSocket
   
   
   void WebSocket::close(uint16_t status, std::string message)
   {
       ESP_LOGD(LOG_TAG, ">>******close()********: status: %d, message: %s", status, message.c_str());
   
       if (m_sentClose) { // If we have previously sent a close request then we can close the underlying socket.
           ESP_LOGD(LOG_TAG, "Closing the underlying socket");
           m_socket.close();          // Close the underlying socket.
           m_pWebSockerReader->end(); // Stop the web socket reader.
           return;
       }
       m_sentClose = true; // Flag that we have sent a close request.
   
       Frame frame; // Build the web socket frame indicating a close request.
       frame.fin = 1;
       frame.rsv1 = 0;
       frame.rsv2 = 0;
       frame.rsv3 = 0;
       frame.opCode = OPCODE_CLOSE;
       frame.mask = 0;
       frame.len = message.length() + 2;
       int rc = m_socket.send((uint8_t*)&frame, sizeof(frame));
   
       if (rc > 0) {
           rc = m_socket.send(status);
       }
   
       if (rc > 0) {
           m_socket.send(message);
       }
   
       if (m_receivedClose || rc == 0 || rc == -1) {
           m_socket.close();          // Close the underlying socket.
           m_pWebSockerReader->end(); // Stop the web socket reader.
       }
   } // close
   
   
   WebSocketHandler* WebSocket::getHandler()
   {
       return m_pWebSocketHandler;
   } // getHandler
   
   
   Socket WebSocket::getSocket()
   {
       return m_socket;
   } // getSocket
   
   
   void WebSocket::send(std::string data, uint8_t sendType)
   {
       ESP_LOGD(LOG_TAG, ">> send: Length: %d", data.length());
       Frame frame;
       frame.fin = 1;
       frame.rsv1 = 0;
       frame.rsv2 = 0;
       frame.rsv3 = 0;
       frame.opCode = (sendType == SEND_TYPE_TEXT) ? OPCODE_TEXT : OPCODE_BINARY;
       frame.mask = 0;
       if (data.length() < 126) {
           frame.len = data.length();
           m_socket.send((uint8_t*)&frame, sizeof(frame));
       } else {
           frame.len = 126;
           m_socket.send((uint8_t*)&frame, sizeof(frame));
           m_socket.send(htons((uint16_t)data.length())); // Convert to network byte order from host byte order
       }
       m_socket.send((uint8_t*)data.data(), data.length());
       ESP_LOGD(LOG_TAG, "<< send");
   } // send_cpp
   
   
   void WebSocket::send(uint8_t* data, uint16_t length, uint8_t sendType)
   {
       ESP_LOGD(LOG_TAG, ">> send: Length: %d", length);
       Frame frame;
       frame.fin = 1;
       frame.rsv1 = 0;
       frame.rsv2 = 0;
       frame.rsv3 = 0;
       frame.opCode = (sendType == SEND_TYPE_TEXT) ? OPCODE_TEXT : OPCODE_BINARY;
       frame.mask = 0;
       if (length < 126) {
           frame.len = length;
           m_socket.send((uint8_t*)&frame, sizeof(frame));
       } else {
           frame.len = 126;
           m_socket.send((uint8_t*)&frame, sizeof(frame));
           m_socket.send(htons(length)); // Convert to network byte order from host byte order
       }
       m_socket.send(data, length);
       ESP_LOGD(LOG_TAG, "<< send");
   }
   
   
   void WebSocket::setHandler(WebSocketHandler* pHandler)
   {
       m_pWebSocketHandler = pHandler;
   } // setHandler
   
   
   void WebSocket::startReader()
   {
       ESP_LOGD(LOG_TAG, ">>>>>>>>>>>>>>>>>>>>>***reader****************************************");
       ESP_LOGD(LOG_TAG, ">> startReader: Socket: %s", m_socket.toString().c_str());
       m_pWebSockerReader->start(this);
   } // startReader
   
   
   WebSocket* WebSocket::getClient(int fd)
   {
       ws_list_t::iterator it;
       it = wsClients.find(fd);
       return it->second;
   }
   
   void WebSocket::removeClientFromQueue(int fd)
   {
       //remove by key
       wsClients.erase(fd);
       //remove by iterator
       /* ws_list_t::iterator it;
       it = wsClients.find(fd);
       wsClients.erase(it)  */
   }
   
   
   bool WebSocket::addClientToQueue(int fd, WebSocket* socket)
   {
       if (wsClients.size() < WEBSOCKET_SERVER_MAX_CLIENTS) {
           ::wsClients.insert(std::pair<int, WebSocket*>(fd, socket));
           return true;
       }
   
       return false;
   }
   
   WebSocketInputStreambuf::WebSocketInputStreambuf(
       Socket socket,
       size_t dataLength,
       uint8_t* pMask,
       size_t bufferSize)
   {
       m_socket = socket;         // The socket we will be reading from
       m_dataLength = dataLength; // The size of the record we wish to read.
       m_pMask = pMask;
       m_bufferSize = bufferSize;       // The size of the buffer used to hold data
       m_sizeRead = 0;                  // The size of data read from the socket
       m_buffer = new char[bufferSize]; // Create the buffer used to hold the data read from the socket.
   
       setg(m_buffer, m_buffer, m_buffer); // Set the initial get buffer pointers to no data.
   } // WebSocketInputStreambuf
   
   
   WebSocketInputStreambuf::~WebSocketInputStreambuf()
   {
       delete[] m_buffer;
       discard();
   } // ~WebSocketInputRecordStreambuf
   
   
   void WebSocketInputStreambuf::discard()
   {
       uint8_t byte;
       ESP_LOGD("WebSocketInputStreambuf", ">> discard: Discarding %d bytes", m_dataLength - m_sizeRead);
       while (m_sizeRead < m_dataLength) {
           m_socket.receive(&byte, 1);
           m_sizeRead++;
       }
       ESP_LOGD("WebSocketInputStreambuf", "<< discard");
   } // discard
   
   
   size_t WebSocketInputStreambuf::getRecordSize()
   {
       return m_dataLength;
   } // getRecordSize
   
   
   WebSocketInputStreambuf::int_type WebSocketInputStreambuf::underflow()
   {
       ESP_LOGD("WebSocketInputStreambuf", ">> underflow");
   
       // If we have already read as many bytes as our record definition says we should read
       // then don't attempt to ready any further.
       if (m_sizeRead >= getRecordSize()) {
           ESP_LOGD("WebSocketInputStreambuf", "<< underflow: Already read maximum");
           return EOF;
       }
   
       // We wish to refill the buffer.  We want to read data from the socket.  We want to read either
       // the size of the buffer to fill it or the maximum number of bytes remaining to be read.
       // We will choose which ever is smaller as the number of bytes to read into the buffer.
       size_t remainingBytes = getRecordSize() - m_sizeRead;
       size_t sizeToRead;
       if (remainingBytes < m_bufferSize) {
           sizeToRead = remainingBytes;
       } else {
           sizeToRead = m_bufferSize;
       }
   
       ESP_LOGD("WebSocketInputRecordStreambuf", "- getting next buffer of data; size request: %d", sizeToRead);
       size_t bytesRead = m_socket.receive((uint8_t*)m_buffer, sizeToRead, true);
       if (bytesRead == 0) {
           ESP_LOGD("WebSocketInputRecordStreambuf", "<< underflow: Read 0 bytes");
           return EOF;
       }
   
       // If the WebSocket frame shows that we have a mask bit set then we have to unmask the data.
       if (m_pMask != nullptr) {
           for (int i = 0; i < bytesRead; i++) {
               m_buffer[i] = m_buffer[i] ^ m_pMask[(m_sizeRead + i) % 4];
           }
       }
   
       m_sizeRead += bytesRead; // Increase the count of number of bytes actually read from the source.
   
       setg(m_buffer, m_buffer, m_buffer + bytesRead); // Changethe buffer pointers to reflect the new data read.
       ESP_LOGD("WebSocketInputRecordStreambuf", "<< underflow - got %d more bytes", bytesRead);
       return traits_type::to_int_type(*gptr());
   } // underflow
   
   
   WebSocketHandler::~WebSocketHandler()
   {
   } // ~WebSocketHandler()
